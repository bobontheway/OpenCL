Execution of Kernels and Memory Object Commands
clEnqueueMarker
clEnqueueWaitForEvents
clEnqueueBarrier

[内核执行，以及内存对象命令]
- s
- s
- s



========================================

和如下函数有什么区别：
（1）clFinish
（2）clWaitEvents
（3）clFlush

========================================
为了定义更通用的点，OpenCL 使用 events 和 marker。


in-order 和 out-of-order 的区别：
（1）命令队列中的命令发送到设备执行的顺序；
（2）命令执行返回的顺序；

[参考： opencl programming guild - chaper 9]
==========================================================
[参考： opencl programming guild - chaper 1]
起因：定义内存对象的一致性，相对于命令队列中的命令。
实现：
（1）内存模型：relaxed consistency model 的修改版本；
（2）实现：所有的工作项在执行内核代码时，并且已经完成，对内存对象的加载/存储操作已经完成，在内核命令标识完成前；

补充：
（1）对于 in-order 命令队列，这写在内核之间足够定义内存一致性；
（2）对于 out-of-order 队列，有两个可选的同步点（synchronization points）；
- 第一个，在指定的点，用来强制一致性，例如 command-queue barrier；
- 另一个，通过事件机制（event）明确的管理一致性；

相同：强制 `主机` 和 `OpenCL 设备` 之间的一致性；也就是说，内存一致性，只发生在命令队列中的同步点。

==========================================================
**********************************************************
问题
**********************************************************
==========================================================
（1）clEnqueueBarrier() 和 clEnQueueMarker() 的相同点和不同点？这两个有什么区别，分别用于什么场景？
- 在同步点之后的命令开始执行时，同步点之前的命令已经执行完成；
- 在命令队列中提交一个 clEnqueueBarrier() 命令，用来定义一个同步点；
- 对于了解命令之间的顺序约束非常重要；
- 同步点，内存一致性模型；

小结：
对于 clEnqueueNDRangeKernel 函数，并非以阻塞的方式执行；

