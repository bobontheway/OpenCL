http://netaz.blogspot.co.il/2015/03/androids-graphics-buffer-management.html

Android's Graphics Buffer Management System (Part I: gralloc)

在这个系列的文章中，我将深入 Android 的图形缓冲管理系统。我将涉及到

我将涉及到，camera 是如何使用通用的 BufferQueue 抽象层来生成缓冲区的，并将其
流到系统的不同部分。缓冲区是如何在不同的硬件模块之间共享；它们是如何跨越进程
边界的。

但是我将从缓冲区的分配开始，在开始之前我将描述是什么触发了缓冲区的分配，什么
时候分配，让我们一起看看底层的图形缓冲区分配器，又称作 gralloc。

gralloc:缓冲区分配器
gralloc 是硬件抽象曾（HAL）的一部分，这意味着它的实现是和平台相关的。你可以查
看在 `hardware/libhardware/include/hardware/gralloc.h` 中定义的接口。正如 HAL
组件所期望的那样，接口分为模块接口（gralloc_module_t）和设备接
口（alloc_device_t）。gralloc 模块的加载和所有 HAL 模块的加载相同，因此我将不
详细介绍，因为在网上可以很容易的搜索到。但是我要说的是新加载的 HAL 模块的进入
点，是通过 hw_module_methods 结构的 open 方法，它被 hw_module_t 结构引用。
hw_module_t 扮演了包括 gralloc_module_t 的所有模块的基类（并不完全一样，因为
这是 c 代码）。

模块和设备接口都有特定的版本。当前的模块版本是 0.3，设备版本为 0.1。只有 goole
知道为什么这些接口拥有子1.0 的接口版本。

正如上面所说，gralloc 的实现是平台相关的，作为参考，可以查看 goldfish 的设备实
现（device/generic/goldfish/opengl/system/gralloc/gralloc.c）。Goldfish 是
Android 仿真平台设备的代号名字。
（alloc_device_t）设备的唯一责任是分配（和随之而来的释放）缓冲区内存，因此它拥
有直接的签名。
...	...	...
alloc_device_t 结构体描述

让我们检查 alloc() 函数的参数，第一个参数（dev）当然是实例的句柄。接下来的两个
参数（w，h）提供了请求的缓冲区的宽度（width）和高度（height）。当描述图形缓冲区
的维度（大小）时，有两点需要注意。首先，我们需要了解尺寸的单位，如果希望的尺寸
是以像素为单位，例如 gralloc 的情况，接着我们需要理解如何将像素转换为比特位。为
此我们需要知道颜色编码的格式。

请求的颜色格式为第四个参数。Android 支持的颜色格式在
`system/core/include/system/graphics.h` 中定义，颜色
格式 HAL_PIXEL_FORMAT_RGBA_8888 使用 32 位来为每个像素表示（像素中每个像素的通
道占据 8 位：red，green，blue 和 alpha-blending），当 HAL_PIXEL_FORMAT_RGB_565
每个像素占用 16 位时（5 位用于 red 和 blue，6 位用于 green）。

影响图形缓冲区物理尺寸第二重要的因素是它的 stride。stride 是 alloc() 函数的最
后一个参数，并且它也是一个输出参数。为了理解 stride（又称作 pitch），参考下面
的图最容易理解：
...	...	...
图

我们可以把内存缓冲区看作是排列成行和列的矩阵。row 通常称作行。stride 定义为像
素的数目（或者字节，这依赖于单位），这需要从一个缓冲区行的开始位置数，到下一
个缓冲区行。如上图所显示的那样，stride 必须至少等于缓冲区的宽度，但是也可以比
宽度大。stride 和 width 之间的不同（stride-width）只是浪费内存，还有一个内存
用来存储一个图像或者图形不是连续的。因此，stride 来源于哪里？这是由于硬件实现
的复杂性，内存带宽优化和其它的限制（约束）。当硬件访问图形缓冲区时，可能要求
缓冲区是一些字节数目的整数倍。例如，对于一个特定的硬件模块，行地址需要对齐到
64 字节，然后内存带宽需要是 64 字节的整数倍。如果这个约束导致行的大小大于请
求的行，这时缓冲区的 stride 就和 width 不同。stride 的另一个动机是缓冲区的重
用：假设你想引用一个在另一个图像素的 cropped 图像。在这种情况下，cropped（内
部的图像拥有一个 stride 和 width 不一样。
...	...	...
图

分配的缓冲区可用于写入或读取，这和用户空间的代码有关，但最初，它被写入，或者
被不同的硬件模块，例如 GPU（图形处理单元），camera，合成引擎，DMA 引擎，显示
控制器等设备从它读取数据。在一个典型的 SoC 中，这些硬件模块来自不同的厂商，并
对缓冲区内存拥有不同的约束，当他们使用共享缓冲区时，所有的约束都需要满足。例
如，GPU 向缓冲区中写入数据，显示控制器可以正确读取数据。在缓冲区上的不同约束
不一定是异构组件厂商的结果，而是由于不同的优化点。在一些情况下，gralloc 需要
保证图像格式和内存布局需要同时满足图像的生产者和消费者。这就是 `usage` 参数
发挥作用的地方。

`usage`标识在 gralloc.h 头文件中定义。前面四个最低有效位（bits 0-3）描述了软
件是如何读取缓冲区的（never，rarely 和 often）；接下来的四位（bits 4-7）描述
了软件是如何写缓冲区的（never，rarely 和 often）。接下来的十二位描述了硬件是
如何使用该缓冲区的：作为一个 OpenGL ES 纹理，或 OpenCL ES 渲染目标；通过 2D
硬件块传输器，帧缓冲区设备或 HW 视频解码器；通过 HW camera pipeline 来写或者
读；作为零快门延迟相机队列的一部分；用于 RenderScript 分配；在外部显示器显示
为全屏；或者用作光标。

很明显，颜色格式和 usage 标识可能存在某种耦合。例如，如果 `usage` 参数表示该
缓冲区被 camera 写入数据，并且被视频编码器（encoder）读取数据，那这个格式必
须被两个硬件模块所识别。

如果软件需要访问缓冲区的内容，读或者写入，gralloc 需要确保有一个从物理地址空
间到 CPU 的虚拟地址空间的映射，并且 cache 保证了一致性。

对于一个示例（sample）的实现，你可以参考 goldfish 设备的实现，在
device/generic/goldfish/opengl/system/gralloc/gralloc.cpp

影响缓冲内存的其它因素
有一些其它的因素会影响图形和图像内存是如何分配的，还有图像是如何存储（内存
布局）和访问的，我们应该简要回顾一下：

对齐
再次，不同的硬件可能会强制硬件或软件内存对其要求。不遵从硬件要求将导致硬件执
行其功能的错误，同时不遵从软件要求将导致硬件的次优（sub-optimal）使用（通常表
现在功耗、温度和性能方面）。

颜色空间，格式和内存布局
有多个颜色空间（color spaces），最熟悉的是 YCbCr（图像）和 RGB（图形）。在每
个颜色空间中，信息可以用不同的方式编码。一些样品的编码包括 RGB565（16 bits；
5 位用来表示红色和蓝色，6 位表示绿色），RGB888（24 bits）或 ARGB8888（32 位；
还有 alpha-blending 通道）。YCbCr 编码格式通常使用了色度抽样。

由于我们的眼睛对颜色的敏感度要比灰度级低，所以色读通道的采样率要比 luma 通道
要低，而感知质量的损失也很少。使用的采样方案并不一定决定内存布局。例如，对于
4:2:0 采样格式的 NV12 和 YV12，拥有两个不同的内存布局，如下图所示：
...	...	...
图显示

有两种 YUV 格式：packed 格式（也称作 semi-planar）和 planar 格式。NV12 是
packed 格式的示例，YV12 是 planar 格式的示例。在 packed 格式中，Y、U 和 V
通道存放在单独的数组中。像素组织为 macropixels 组中，他们的布局依赖于格式。













































