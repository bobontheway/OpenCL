out-of-order VS in-order

以 `out-of-order` 的方式执行内核和内存对象命令。

调用 OpenCL 函数将命令提交到命令队列时，命令在命令队列中是按照函数调用顺序存放的。但是在命令执行时，其执行顺序并不一定和命令提交到命令队列
的顺序一致。在创建命令队列的时候，可以通过设置 clCreateCommandQueue 函数的 `properties` 参数来指定命令队列中的命令是以 `in-order`
还是 `out-of-order` 的方式执行。

创建命令队列时，如果没有为命令队列设置 `CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE` 属性，提交到命令队列的命令将按照 `in-order` 的方式执行。
在这种执行方式下，如果应用程序首先调用 `clEnqueueNDRangeKernel` 来执行内核 A，接着又调用 `clEnqueueNDRangeKernel` 来执行内核 B，可以认为
内核 A 在 内核 B 之前完成。这时，如果内核 A 输出的内存对象作为内核 B 的输入，内核 B 将正确访问到内核 A 生成的数据。反之，如果在创建命令队
列时设置了 `CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE` 属性，则不能保证内核 A 在内核 B 开始之前已经执行完成。

在创建命令队列时，为命令队列设置 `CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE` 属性，应用程序调用 OpenCL 函数把命令提交到命令队列后，将按
照 `out-of-order` 的方式执行。在 `out-of-order` 执行模式下，不能保证提交到命令队列中的命令是按照函数调用的顺序执行。例如，上面通过调用
`clEnqueueNDRangeKernel` 来执行内核 A 和内核 B 的阐述中，内核 B 可能在内核 A 之前执行完成。为了保证两个内核以一个特定的顺序执行，可以使用
`事件同步`。执行内核 A 时使用 event 事件对象来标识该命令，在随后调用 clEnqueueNDRangeKernel 执行内核 B 时，将 event 事件对象在其`event_wait_list`
参数中指定。

除了`事件同步`可以用于多个内核执行时的同步操作，clEnqueueWaitForEvents（等待事件） 和 clEnqueueBarrier（屏障） 命令也可以提交到命令队列用于同步。
`等待事件`命令保证在随后的命令执行之前，之前提交到命令队列的命令（使用事件列表来标识）已经执行完成；屏障命令保证在后面的命令执行之前，前面提交到
命令队列的命令已经执行完成。

同理，如果为命令队列设置了 `CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE` 属性，OpenCL 函数调用中，在 clEnqueueNDRangeKernel、clEnqueueTask 和
clEnqueueNativeKernel 命令之后提交到命令队列的读、写、拷贝和映射内存对象等命令，并不能保证会等待内核执行完成。为了保证正确的命令执行顺序，
clEnqueueNDRangeKernel、clEnqueueTask 和 clEnqueueNativeKernel 返回的事件对象可以用来将一个`等待事件`提交到命令队列，或者将一个`屏障`命令
提交到命令队列，以保证在读或写内存对象之前内核已经执行完成。

2.函数描述

2.clFinish 和 clEnqueueBarrier 的区别；
- 一个会以阻塞的方式等待，一个会立即返回；主线程可以执行其它的任务；
No.7_1_OpenCLSyncHost - 中有对 clFinish 的描述。

3.clEnqueueMarker 和 clEnqueuelWaitForEvents 搭配；
4.clWaitForEvents 和 clEnqueuelWaitForEvents 的区别；
- 和 `2` 中类似，一个会以阻塞的方式等待，一个会立即返回；

https://www.khronos.org/registry/OpenCL/specs/
https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf





示例程序

这部分通过两个示例程序分别介绍 OpenCL 命令队列的同步和命令队列之间的同步。

两个示例程序，一个用于命令队列的同步；另一个用于两个命令队列的同步。涉及到的函数 clEnqueueBarrier，clEnqueueMarker，clEnqueueWaitForEvents，
关联的函数包括 clFinihs，clWaitForEvents；

