OpenCL 原子操作；
原子操作往往会对总线做一次锁步操作（lock-step），让当前总线上的访存操作能按照次序执行。
同时又会刷新Cache，使得任一县城对全局变量使用了原子操作之后，其它所有线程都可见。

使用原子操作做同步对于执行开销而言是相当大的，但是对于需要使用更原始的阻塞当前线程执
行的同步方式而言又是比较高效的。

因此，当对某些特定数据做同步更新时，不需要使用栅栏等这种更低效的处理机制，我们可以直接
对那些存储地址采用原子操作。

atomic_add
- 在一个原子事物中执行；
- 读取 p 指向位置的内容（用作返回值），将 p 指向位置的内容加上 val 后存入，在存入该位置；
- 内核在多个设备上对统一内存位置执行的原子操作没法保证原子性；

atomic_xchg
原子交换操作常用于对某个变量进行初始化或是作为互斥体（mutex）使用。将 val 存入
p 指向的位置，返回 p 位置修改之前的内容；

atomic_cmpxchg
原子比较交换
如果 p 指向位置的内容和 cmp 相等，则将 val 存放 p 指向的位置，否则 p
指向位置还是原来的值， 返回 p 位置修改前的内容。

atomic_min
原子求最小值，是将最小值写入 p 指向的位置。返回 p 位置更新前的值；

atomic_and/atomic_or/atomic_xor
原子按位与/或操作，返回 p 指向位置更新前的值；

原子操作可以对全局内存区域进行同步！
