=============
Summery.txt |
=============

OpenCL 性能 —— 测量时间
OpenCL 性能 —— 测量带宽

Posix 接口 - 计时功能
- 之前都使用了该接口；
- 精度如何，是如何实现的？
- 如何使用
- timespec 的精度，是否和 Profiling 一致？

Profiling - 计时功能；
- 什么是 Profiling
## 从 5.12 来看，就是用来统计提交到命令队列中命令，记录其时间戳。然后用来分析该命令的执行时间，及系统性能；
## 系统性能包括那些东西？

- 如何使用
- 精度如何，是如何实现的？

两者分别在那些场合下使用，Posix 接口还有没有用？是否有分工


## Profiling 操作

当设备的时钟频率或电源状态发生变化时，要求也能正确的对命令的执行过程进行时间统计。
在调用 clGetDeviceInfo() 函数时，传入 CL_DEVICE_PROFILING_TIMER_RESOLUTION 标识作为参数，可以用来获取 Profiling 操作所使用的定时器精度，以纳秒为单位。
示例代码如下：
```c
int err;
size_t resolution;
err = clGetDeviceInfo(devices[i],
	CL_DEVICE_PROFILING_TIMER_RESOLUTION, sizeof(size_t),
	&resolution, NULL);
printf("Timer resolution: %d\n", (int)resolution);
```

在 AMD OpenCL 平台下，所有的设备使用相同的时钟类型。因此，通过 Profiling 获取的时间戳信息可以在 CPU 和 GPU 设备之间直接比较。使用 strace 命令来跟踪应用
程序的函数调用路径时，可以发现在使用 `CL_DEVICE_PROFILING_TIMER_RESOLUTION` 作为参数调用 clGetDeviceInfo() 函数时，其内部又调用了如下函数：
```c
clock_getres(CLOCK_MONOTONIC, {0, 1})   = 0
```
可以发现 OpenCL 运行库进一步调用 clock_getres() 函数来得到 Profiling 操作所使用的定时器精度，这里为 1 纳秒（在不同的平台上运行可能存在差异）。CLOCK_MONOTONIC（单调递增时钟）
时钟也是前面用来统计函数执行时间所使用的时钟，也就是说 Profiling 操作所生成的时间戳信息可以和前面测量函数执行时间所得到的时间戳直接比较。



///////////

测量执行时间

## 参考

- https://lwn.net/Articles/429925/


clock_gettime 来自于 libc 库，Profiling 的精度也是来自通过调用 clock_getres 的调用。
xbdong@xbdong-opencl:~/Project/tmp/hello1$ ldd ./hello
	linux-vdso.so.1 =>  (0x00007ffd7e1fd000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7924be9000)
	/lib64/ld-linux-x86-64.so.2 (0x000056475be2f000)







==================================
先搭个框架，在逐步增加
==================================

在 ARM T-880 的平台上，定时器的精度为 1000 纳秒；在 AMD RX-460 的平台上，定时器的精度为 1 纳秒。

5.12 对内存对象和内核的分析（Profiling）操作

返回的无符号的 64 位值可以用来测量 OpenCL 命令消耗的时间，以纳秒为单位。

...

如果 clGetEventProfilingInfo 成功执行返回 CL_SUCCESS，同时分析信息被记录
下来。否则，返回下面的错误值。
...	...


======================
Performance
======================

Memory performance

1.read v1, v2, v4, v8, v16
- workgroup size = NULL

2.read v1
- workgroup size = 32, 64, 128, 256


Compute performance
1.compute float v1, v2, v4, v8, v16
- workgroup size = NULL

2.compute float v1
- workgroup size = 32, 64, 128, 256

======================
Compute performance
Peak single precision float 	72.81 GFLOP/s
Peak integer			81.36 GFLOP/s
Peak short			152.15GFLOP/s

Memory bandwidth
Kernel copy		12.30 GB/s
Kernel write		12.10 GB/s
Kernel read		8.37 GB/s

General performance
Kernel latency		0.252 ms
Accuracy test		passed

==================================
- Q1_execution_time.txt
==================================



下面的示例代码显示了如何计算内核的执行时间（结束-开始）：
...	...

另一个跟踪的有趣度量是内核的启动时间（Start-Queue）。内核
启动时间同时包括消耗在用户应用中（执行提交到命令队列，但
是在提交到设备之前）还有消耗在运行库中用来启动内核的时间。
对于 CPU 设备，内核的启动时间非常快（几十微秒），但是对于
独立的 GPU 设备，这时间可能达到几百微秒。在命令中使能
profiling 功能，对所有的 clEnqueue 调用，会额外添加大约
10 微秒到 40 微秒的时间消耗。很多 profiling 的消耗影响开始
（start）时间；因此，这也会影响启动时间。在解释这个测量时
需要小心。为了降低启动（launch）时间的消耗，AMD 的 OpenCL
运行库将提交的多个命令合并到到一批处理。提交的一批命令，给
出类似（similar）的开始时间和相同的结束时间。

5.4.2 使用 OpenCL 定时器和其它的系统定时器
定时器的精度，以纳秒为单位，可以通过下面的方式获得：
clGetDEviceInfo(..., CL_DEVICE_PROFILING_TIMER_RESOLUTION...);


==================================
- Q1.txt
==================================
5. OpenCL 性能和优化
本文讨论当为 AMD APP GPU 计算、CPU，以及 GPU 和 CPU 的组合，等设备编程时的性能和优化。和 Southern Islands 系列 GPU 相关的详细细节在本章的
末尾描述。

5.1 CodeXL GPU Profiler 介绍
CodeXL GPU Profiler（后面称作 Profiler）是性能分析工具，在 OpenCL 应用程序执行时，用来从 OpenCL run-time 和 AMD Radeon GPUs 获取数据信息。
这些信息在 AMD 的平台下，用来发现应用程序中的瓶颈，并找到方法以优化应用程序的性能。下面的部分描述 Profiler 支持的操作模式。

5.1.1 收集 OpenCL 应用执行信息

当被剖析的应用程序执行完后，CodeXL 显示会话。


==================================
- Q2_memory_bandwidth.txt
==================================

计算内存带宽

添加：
关于时间，只需要计算命令执行的 end -start 阶段即可。

内核需要的内存带宽可能是最重要的性能考量指标，计算如下

有效带宽 = (Br + Bw) / T

参数如下：
- Br：从全局内存区域读取的总的字节数；
- Wr：写到全局内存区域的总字节数目；
- T：运行内核程序需要的时间，以纳秒为单位；

如果 Br 和 Bw 使用使用字节来表示，同时 T 以纳秒为单位，
最后的有效带宽测量以 GB/s 为单位，这适合于当前的 CPUs 和 GPUs，
当它们的峰值为 20-260 GB/s 时。计算 Br 和 Bw 要求彻底理解内核
算法，这也是一种高效的方法来优化性能。为了说明目的，考虑一个简
单的矩阵加法：每个元素在两个源矩阵中只读一次，执行加法操作，然
后存储到第三个矩阵中。1024x1024 矩阵加法的有效带宽计算如下：
Br = 2 * (1024 * 1024 * 4 bytes) = 8388608 bytes；
2 个阵列，1024x1024，每个元素是 4 bytes 的浮点类型

Bw = 1 * (1024 * 1024 * 4 bytes) = 4194304 bytes
1 个阵列，1024x1024，每个元素是 4 bytes 的浮点类型

如果这次拷贝经过的时间，通过 profiling 定时器报道的时间为
1000000 ns（1 million ns，或者 0.001 秒）。有效的带宽为：
（Br + Bw）/ T = (8388608+4194304)/1000000 = 12.6GB/s


==================================
- Q2_memory_bandwidth.txt
==================================
对于时间测量可以提供下面的示例，找出重点部分，测算内核启动时间
/opt/AMDAPPSDK-3.0/samples/opencl/cl/1.x/KernelLaunch/docs

