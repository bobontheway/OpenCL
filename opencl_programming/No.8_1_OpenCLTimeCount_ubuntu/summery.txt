=============
Summery.txt |
=============

OpenCL 性能分析
- 测量时间
- 测量带宽

## Profiling 操作

==================================
先搭个框架，在逐步增加
==================================

5.12 对内存对象和内核的分析（Profiling）操作

======================
Performance
======================

Memory performance

1.read v1, v2, v4, v8, v16
- workgroup size = NULL

2.read v1
- workgroup size = 32, 64, 128, 256


Compute performance
1.compute float v1, v2, v4, v8, v16
- workgroup size = NULL

2.compute float v1
- workgroup size = 32, 64, 128, 256

======================
Compute performance
Peak single precision float 	72.81 GFLOP/s
Peak integer			81.36 GFLOP/s
Peak short			152.15GFLOP/s

Memory bandwidth
Kernel copy		12.30 GB/s
Kernel write		12.10 GB/s
Kernel read		8.37 GB/s

General performance
Kernel latency		0.252 ms
Accuracy test		passed

==================================
- Q1_execution_time.txt
==================================



下面的示例代码显示了如何计算内核的执行时间（结束-开始）：
...	...

另一个跟踪的有趣度量是内核的启动时间（Start-Queue）。内核
启动时间同时包括消耗在用户应用中（执行提交到命令队列，但
是在提交到设备之前）还有消耗在运行库中用来启动内核的时间。
对于 CPU 设备，内核的启动时间非常快（几十微秒），但是对于
独立的 GPU 设备，这时间可能达到几百微秒。在命令中使能
profiling 功能，对所有的 clEnqueue 调用，会额外添加大约
10 微秒到 40 微秒的时间消耗。很多 profiling 的消耗影响开始
（start）时间；因此，这也会影响启动时间。在解释这个测量时
需要小心。为了降低启动（launch）时间的消耗，AMD 的 OpenCL
运行库将提交的多个命令合并到到一批处理。提交的一批命令，给
出类似（similar）的开始时间和相同的结束时间。




==================================
- Q2_memory_bandwidth.txt
==================================

计算内存带宽

添加：
关于时间，只需要计算命令执行的 end -start 阶段即可。

内核需要的内存带宽可能是最重要的性能考量指标，计算如下

有效带宽 = (Br + Bw) / T

参数如下：
- Br：从全局内存区域读取的总的字节数；
- Wr：写到全局内存区域的总字节数目；
- T：运行内核程序需要的时间，以纳秒为单位；

如果 Br 和 Bw 使用使用字节来表示，同时 T 以纳秒为单位，
最后的有效带宽测量以 GB/s 为单位，这适合于当前的 CPUs 和 GPUs，
当它们的峰值为 20-260 GB/s 时。计算 Br 和 Bw 要求彻底理解内核
算法，这也是一种高效的方法来优化性能。为了说明目的，考虑一个简
单的矩阵加法：每个元素在两个源矩阵中只读一次，执行加法操作，然
后存储到第三个矩阵中。1024x1024 矩阵加法的有效带宽计算如下：
Br = 2 * (1024 * 1024 * 4 bytes) = 8388608 bytes；
2 个阵列，1024x1024，每个元素是 4 bytes 的浮点类型

Bw = 1 * (1024 * 1024 * 4 bytes) = 4194304 bytes
1 个阵列，1024x1024，每个元素是 4 bytes 的浮点类型

如果这次拷贝经过的时间，通过 profiling 定时器报道的时间为
1000000 ns（1 million ns，或者 0.001 秒）。有效的带宽为：
（Br + Bw）/ T = (8388608+4194304)/1000000 = 12.6GB/s


==================================
- Q2_memory_bandwidth.txt
==================================
对于时间测量可以提供下面的示例，找出重点部分，测算内核启动时间
/opt/AMDAPPSDK-3.0/samples/opencl/cl/1.x/KernelLaunch/docs


5.4.2 使用 OpenCL 定时器和其它的系统定时器

5. OpenCL 性能和优化
本文讨论当为 AMD APP GPU 计算、CPU，以及 GPU 和 CPU 的组合，等设备编程时的性能和优化。和 Southern Islands 系列 GPU 相关的详细细节在本章的
末尾描述。

5.1 CodeXL GPU Profiler 介绍
CodeXL GPU Profiler（后面称作 Profiler）是性能分析工具，在 OpenCL 应用程序执行时，用来从 OpenCL run-time 和 AMD Radeon GPUs 获取数据信息。
这些信息在 AMD 的平台下，用来发现应用程序中的瓶颈，并找到方法以优化应用程序的性能。下面的部分描述 Profiler 支持的操作模式。

5.1.1 收集 OpenCL 应用执行信息

当被剖析的应用程序执行完后，CodeXL 显示会话。

在 ARM T-880 的平台上，定时器的精度为 1000 纳秒；在 AMD RX-460 的平台上，定时器的精度为 1 纳秒。
